package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"gqlgen-prisma/db"
	"gqlgen-prisma/graph"
	"gqlgen-prisma/graph/model"
)

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.db.User.FindMany().Exec(ctx)
	res := make([]*model.User, len(users))
	for i, u := range users {
		res[i] = convertToUserResponse(&u)
	}

	return res, err
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, err := r.db.User.FindUnique(db.User.ID.Equals(id)).Exec(ctx)
	return convertToUserResponse(user), err
}

// Posts is the resolver for the posts field.
func (r *userResolver) Posts(ctx context.Context, obj *model.User) ([]*model.Post, error) {
	// FIXME: prisma-client-go doesn't support dataloader yet. cf)https://www.prisma.io/docs/guides/performance-and-optimization/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prismas-dataloader
	u, err := r.db.User.FindUnique(db.User.ID.Equals(obj.ID)).With(db.User.Posts.Fetch()).Exec(ctx)
	if err != nil {
		return nil, err
	}

	posts := u.Posts()
	res := make([]*model.Post, len(posts))
	for i, p := range posts {
		res[i] = convertToPostResponse(&p)
	}
	return res, nil
}

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
